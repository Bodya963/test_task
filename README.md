

---

# Индексация бинарных файлов с помощью дерева Меркла (дерева хешей)

## Дерево Меркла

**Дерево Меркла** (или дерево хешей) — это бинарное дерево, в котором:
- **Листовые узлы** содержат хеши отдельных блоков данных.
- **Внутренние узлы** содержат хеши от хешей своих дочерних узлов.
- **Корневой узел** содержит финальный хеш всего дерева, который можно использовать для проверки целостности данных и быстрого сравнения файлов.

**Преимущества:**
- **Эффективность**: Позволяет быстро проверять целостность данных и находить изменения.
- **Надежность**: Любое изменение в данных приводит к изменению корневого хеша.
- **Сложность сравнения**: Алгоритм сравнения имеет сложность \(O(\log(n))\), где \(n\) — размер файла.




## Описание работы

### Допустимая ошибка сравнения

Благодаря допустимой ошибке сравнения `E`, мы можем управлять размером и структурой дерева Меркла:
- **Если `E` меньше 50**: Файл будет разделён на большее количество частей, чтобы не более одной части файла была разной. Чем меньше `E`, тем больше частей файл будет иметь.
- **Если `E` больше 50**: Файл будет разделён на меньшее количество частей, чтобы хотя бы одна часть файла совпадала.

### Создание дерева Меркла

1. **Инициализация хэширования**:
   - Используется функция `blake3_hasher_init` для инициализации хэшера.
   - Функция `blake3_hasher_update` добавляет данные из файла в хэшер.
   - Функция `blake3_hasher_finalize` завершает хэширование и возвращает финальный хеш.

2. **Структура дерева**:
   - **`node`**: Структура, содержащая хеш и указатели на дочерние узлы.
   - **`hash_tree`**: Структура, содержащая информацию о дереве, такие как имя файла, количество листьев, основной хеш и указатели на левое и правое поддеревья.

3. **Функции для работы с деревом**:
   - **`make_size_leaf`**: Вычисляет количество листьев и емкость дерева в зависимости от допустимой ошибки `E`.
   - **`get_size_file`**: Возвращает размер файла в байтах.
   - **`make_tree`**: Создаёт дерево Меркла из бинарного файла с заданной допустимой ошибкой `E`.
   - **`create_struct_tree`**: Создаёт структуру дерева с заданным количеством листьев.
   - **`make_hash_in_tree`**: Заполняет дерево хешами данных из файла.
   - **`merge_hash`**: Создаёт хеш из двух хешей.
   - **`make_hash`**: Создаёт хеш из данных файла.
   - **`delete_tree`**: Освобождает память, выделенную под дерево.
   - **`delete_hash_tree`**: Освобождает память, выделенную под дерево хешей.
   - **`print_hash`**: Печатает хеш.
   - **`print_tree`**: Рекурсивно печатает дерево хешей.
   - **`print_hash_tree`**: Печатает полностью дерево хешей.
   - **`compar_tree`**: Сравнивает два дерева Меркла. Возвращает 1, если они равны с допустимой ошибкой `E`, и 0, если не равны.
   - **`compar_hash`**: Сравнивает два хеша. Возвращает 1, если они равны, и 0, если не равны.
   - **`compar_node`**: Сравнивает два поддерева. Возвращает 1, если они совпадают или если допустимая ошибка `E` позволяет одному листу быть разным, и 0 в противном случае.

## Сложность алгоритма сравнения

Благодаря использованию дерева Меркла, сложность алгоритма сравнения составляет \(O(\log(n))\), где \(n\) — размер файла. Это делает сравнение файлов очень эффективным даже для больших данных.

## Зависимости

- **BLAKE3**: Криптографическая хэш-функция для создания хешей.


## Установка зависимостей

### BLAKE3

1. **Клонирование репозитория BLAKE3**:
   ```bash
   git clone https://github.com/BLAKE3-team/BLAKE3.git
   cd BLAKE3
   ```

2. **Компиляция и установка**:
   ```bash
   mkdir build
   cd build
   cmake ..
   make
   sudo make install
   ```



## Компиляция и запуск

1. **Клонирование репозитория**:
   ```bash
   git clone https://github.com/your-repo-link.git
   cd your-repo-link
   ```

2. **Компиляция**:
   ```bash
   make
   ```

3. **Запуск программы**:
   ```bash
   ./indexer E
   ```
   Где `E` — допустимая ошибка сравнения (в процентах, от 0 до 100).

## Пример использования

```bash
./indexer 10
```

   
